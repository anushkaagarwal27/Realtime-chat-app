<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Multi-Room Chat</title>
    <link rel="stylesheet" href="style.css" />
    <script type="module" src="https://cdn.jsdelivr.net/npm/emoji-picker-element@^1/index.js"></script>
</head>

<body>
    <div class="app">
        <aside class="sidebar">
            <h2>Chat Rooms</h2>
            <input id="username" placeholder="Your name..." />
            <input id="room" placeholder="Room name..." />
            <button id="join">Join</button>
            <h3>Online</h3>
            <ul id="online-users"></ul>
        </aside>

        <section class="chat-window">
            <header class="chat-header">
                <h3 id="room-name">Room: general</h3>
                <div id="room-tabs" class="room-tabs"></div>
            </header>

            <main id="chat" class="chat-area"></main>

            <footer class="chat-footer">
                <input id="message" placeholder="Type a message..." />
                <button id="emoji-btn">ðŸ˜Š</button>
                <button id="send">Send</button>
                <emoji-picker id="emoji-picker"
                    style="display:none; position:absolute; bottom:70px; right:20px;"></emoji-picker>
            </footer>
        </section>
    </div>

    <!-- use CDN client, production build -->
    <script src="https://cdn.socket.io/4.8.1/socket.io.min.js" integrity="" crossorigin="anonymous"></script>

    <script>
        // --- CONFIGURATION ---
        // Replace BACKEND_URL with your TLS-enabled backend domain after deployment.
        // Example: "https://my-chat-app.onrender.com"
        const BACKEND_URL = "https://realtime-chat-app-gc6x.onrender.com";

        // Force websocket-only transport so the client will not request
        // /socket.io/socket.io.js or perform xhr-polling that could return
        // scripts from the backend and trigger CSP eval warnings.
        const socket = io(BACKEND_URL, {
            transports: ["websocket"],
            upgrade: false, 
            forceNew: true
        });
        // ---------------------

        const chat = document.getElementById('chat');
        const messageInput = document.getElementById('message');
        const usernameInput = document.getElementById('username');
        const roomInput = document.getElementById('room');
        const sendBtn = document.getElementById('send');
        const joinBtn = document.getElementById('join');
        const roomNameDisplay = document.getElementById('room-name');
        const emojiBtn = document.getElementById('emoji-btn');
        const emojiPicker = document.getElementById('emoji-picker');
        const onlineList = document.getElementById('online-users');
        const roomTabs = document.getElementById('room-tabs');

        let joinedRooms = new Set();
        let activeRoom = 'general';
        const unreadCounts = {};

        function formatTime(t) {
            const d = new Date(Number(t));
            return isNaN(d.getTime())
                ? new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
                : d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }

        // SECURITY FIX: Use textContent and element builders to avoid injecting HTML
        function createMessage({ user, msg, time, room, id }, isSystem = false) {
            if (room !== activeRoom) return;

            const isSelf = user === (usernameInput.value || 'Anonymous').trim();
            const wrapper = document.createElement('div');
            wrapper.className = `message ${isSelf ? 'sent' : 'received'}`;
            wrapper.dataset.id = id;

            const bubble = document.createElement('div');
            bubble.className = 'bubble';

            if (isSystem) {
                const meta = document.createElement('div');
                meta.className = 'meta system';
                meta.textContent = msg;
                bubble.appendChild(meta);
            } else {
                const textDiv = document.createElement('div');
                textDiv.className = 'text';
                textDiv.textContent = msg;

                const metaDiv = document.createElement('div');
                metaDiv.className = 'meta';

                const userSpan = document.createElement('span');
                userSpan.className = 'meta-user';
                userSpan.textContent = user;

                const sep = document.createTextNode(' â€¢ ');

                const timeSpan = document.createElement('span');
                timeSpan.className = 'meta-time';
                timeSpan.textContent = formatTime(time);

                const readSpan = document.createElement('span');
                readSpan.className = 'read';
                readSpan.style.display = 'none';
                readSpan.textContent = 'âœ“âœ“';

                metaDiv.appendChild(userSpan);
                metaDiv.appendChild(sep);
                metaDiv.appendChild(timeSpan);
                metaDiv.appendChild(readSpan);

                bubble.appendChild(textDiv);
                bubble.appendChild(metaDiv);
            }

            wrapper.appendChild(bubble);
            chat.appendChild(wrapper);
            chat.scrollTop = chat.scrollHeight;

            if (!isSystem && !isSelf) {
                socket.emit('message read', { room: activeRoom, msgId: id });
            }
        }

        function switchRoom(room) {
            activeRoom = room;
            roomNameDisplay.textContent = `Room: ${room}`;
            chat.innerHTML = '';
            unreadCounts[room] = 0;
            updateRoomTabBadge(room);
        }

        function updateRoomTabBadge(room) {
            const tab = document.querySelector(`.room-tab[data-room="${room}"]`);
            if (tab) {
                const count = unreadCounts[room] || 0;
                const badge = tab.querySelector('.badge');
                badge.textContent = count > 0 ? String(count) : '';
            }
        }

        function addRoomTab(room) {
            const tab = document.createElement('button');
            tab.className = 'room-tab';
            tab.dataset.room = room;

            const label = document.createElement('span');
            label.textContent = room;

            const badge = document.createElement('span');
            badge.className = 'badge';
            badge.textContent = '';

            tab.appendChild(label);
            tab.appendChild(badge);

            tab.addEventListener('click', () => switchRoom(room));
            roomTabs.appendChild(tab);
        }

        joinBtn.addEventListener('click', () => {
            const room = (roomInput.value || 'general').trim();
            const user = (usernameInput.value || 'Anonymous').trim();

            if (!joinedRooms.has(room)) {
                socket.emit('join room', { room, user });
                joinedRooms.add(room);
                addRoomTab(room);
            }

            switchRoom(room);
        });

        sendBtn.addEventListener('click', () => {
            const msg = messageInput.value.trim();
            if (!msg) return;
            const user = (usernameInput.value || 'Anonymous').trim();
            socket.emit('chat message', { room: activeRoom, user, msg });
            messageInput.value = '';
        });

        messageInput.addEventListener('keydown', e => {
            if (e.key === 'Enter') sendBtn.click();
        });

        emojiBtn.addEventListener('click', () => {
            emojiPicker.style.display = emojiPicker.style.display === 'none' ? 'block' : 'none';
        });

        emojiPicker.addEventListener('emoji-click', e => {
            messageInput.value += e.detail.unicode;
            emojiPicker.style.display = 'none';
        });

        socket.on('chat message', data => {
            if (data.room === activeRoom) {
                createMessage(data);
            } else {
                unreadCounts[data.room] = (unreadCounts[data.room] || 0) + 1;
                updateRoomTabBadge(data.room);
            }
        });

        socket.on('system message', data => {
            if (data.room === activeRoom) createMessage(data, true);
        });

        socket.on('message read', ({ msgId }) => {
            const msg = document.querySelector(`[data-id="${msgId}"] .read`);
            if (msg) msg.style.display = 'inline';
        });

        socket.on('online users', users => {
            // Rebuild online list safely
            onlineList.innerHTML = '';
            users.forEach(u => {
                const li = document.createElement('li');
                li.textContent = u.user;
                onlineList.appendChild(li);
            });
        });

        // initialize with default tab
        addRoomTab('general');
        switchRoom('general');
    </script>
</body>

</html>

